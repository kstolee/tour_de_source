\section{Results}
\label{sec:results}

In this section, we present the results of each research question.

\subsection{RQ1: Which regular expression language features are most commonly used in python?}
\label{results:re2}

To measure feature usage, we  count the number of usages of each feature per project, per file and as a percent of all distinct regular expression patterns.


\todoNow{in Table~\ref{table:featureStats} remove the nFiles and \%files columns for space}
\input{../analysis_output/featureStats}

\subsubsection{Feature Usage}
\label{sec:featureUsage}
Table~\ref{table:featureStats} displays feature usage from the corpus and relates it to four major regex related projects. Only features appearing in at least 10 projects are listed.
The first column, \emph{rank}, lists the rank of a feature (relative to other features) in terms of the number of projects in which it appears. The next column, \emph{code}, gives a succinct reference string for the feature, and is followed by a \emph{description} column that provides a brief comment on what the feature does.  The \emph{example} column provides a short example of how the feature can be used.
% For example, the most common feature observed in the corpus is \emph{one-or-more repetition}, which is specified in a pattern by using the {\tt +} character in conjunction with some sub-pattern that should repeat one or more times.  The code for this feature is \emph{ADD}, and the short example provided is \verb!z+!.
The next four columns map to the four major research projects chosen for our investigation (see Section~\ref{results:rq2}).  We indicate that a project supports a feature with the `\yes' symbol, and indicate that a project does not support the feature with the `\no' symbol.


The next six columns contain three pairs of usage statistics.  The first pair contains the number and percent of \emph{patterns} that a feature appears in, out of the 13,912 patterns that make up the corpus. The next pair of columns contain the number and percent of \emph{files} that a feature appears in out of the 18,549 files scanned that contain at least one utilization.  The last pair of columns contain the number and percent of \emph{projects} that a feature appears in out of the 1645 projects scanned that contain at least one utilization.

One notable omission from Table~\ref{table:featureStats} is the literal feature, which is used  to specify matching any specific character.  An example pattern that contains only one literal token is the pattern \verb!`a'!.  This pattern only matches the lowercase letter `a'.  The literal feature was found in \DTLfetch{data}{key}{P_LITERAL_PRESENT}{value}\% of patterns.
%, and accounted for \DTLfetch{data}{key}{P_LITERAL_TOKENS}{value}\% of all tokens.
We consider the literal feature to be ubiquitous in all patterns, and necessary for any regex related tool to support, and so exclude it from Table~\ref{table:featureStats} and the rest of the feature analysis.



The eight most commonly used features, ADD, CG, KLE, CCC, ANY, RNG, STR and END,
appear in over half the projects. The remaining 26 features appear in less than half of the projects containing utilizations.
CG is more commonly used in patterns than the highest ranked feature (ADD) by a wide margin (over 8\%).  CG is also more commonly used with respect to how many files it appears in by 2.3\%, while only being present in 12 fewer projects (0.7\%) than ADD.

%The seven most rarely used features,  LKB, ENDZ, BKR, NDEC, BKRN, VWSP and NWNW, appear in fewer than 8.  These seven features are more rarely used than all other features with respect to all three of our usage statistics.  Less than 8\% of scanned projects containing utilizations contain these features.
%removed because this table is not complete - features in less than 10 projects are omitted so talking about the least used is not entirely accurate

%\subsubsection{Potentially Under-Ranked and Over-Ranked Features}
%We note that Table~\ref{table:featureStats} is sorted by the number of projects a feature appears in, but if the table were instead sorted by the number of patterns or files that a feature appears in, the ranking order would be different.

%\todo{include this or not?}
% The WSP feature is present in more patterns than the NCCC feature by a margin of 6.7\%, and in more files by a margin of 4.2\%, yet it is ranked lower than NCCC because it is present in 13 fewer projects (0.8\%).
% The WNW, OPT and QST features follow the same pattern of being under-ranked in terms of the number of patterns and files that they appear in.



\subsubsection{Feature Support in Regex Tools}
 We  mapped the features from the corpus to those features supported by the four regular expression engines described in Section~\ref{sec:related}: brics, hampi, RE2, and Rex.
To create the tool mappings, we consulted documentation for each of the selected regular expression engines. For brics, we collected the set of supported features using the formal grammar\footnote{\url{http://www.brics.dk/automaton/doc/index.html?dk/brics/automaton/RegExp.html}}.  For hampi, we manually inspected the set of regexes included in the {\tt lib/regex-hampi/sampleRegex} file within the hampi repository\footnote{\url{https://code.google.com/p/hampi/downloads/list}} (this may have been an overestimation, as this included more features than specified by the formal grammar\footnote{\url{http://people.csail.mit.edu/akiezun/hampi/Grammar.html}}).  For RE2, we used the  supported feature documentation\footnote{\url{https://re2.googlecode.com/hg/doc/syntax.html}}.  For Rex, we were able to use trial and error because we tried to parse all patterns with Rex, and Rex provides good error feedback when a feature is unsupported.

\todoLast{Were there any features supported by the tools that we did not find in the corpus? Explain either way...tomorrow.  There are many, it seems less critical}


Of the four projects selected for this analysis, RE2 supports the most features (28 features) followed by hampi (25 features),  Rex (21 features), and brics (12 features).  All projects support the 8 most commonly used features except brics, which does not support STR or END.  All projects support NCC, OR, and the four less common repetition features: QST, SNG, DBB and LWB.

No projects support the four look-around features LKA, NLKA, LKB and NLKB.  RE2 and hampi support the LZY, NCG, PNG and OPT features, whereas brics and Rex do not.  Brics is the only project that does not support any of the six default character classes (WSP, DEC, WRD, NWSP, NWRD, NDEC) - the rest of the projects support all of those features.  RE2 is the only project to support the WNW, ENDZ and NWNW features.  RE2 also supports the PNG feature (which allows you to name capturing groups), but does not support the BKRN feature which is necessary to refer back to the named capture group.

\subsubsection{Summary}
We found that the eight most common features are found on over 50\% of the projects.
%Five features that make more appearances in terms of patterns and files than the feature ranked immediately higher than them in terms of appearances in projects.
We also identify brics as the project supporting the fewest features and RE2 as the project supporting the most features, and identify groups of features supported or not supported by the four regex projects.


\subsection{{RQ2:} What is the impact of \emph{not} supporting various regular expression features?}
\label{results:rq3}

%\subsubsection{Rationale for Behavioral Clustering}
When tool designers are considering what features to include, data about usage in practice, beyond syntactic characteristics, is valuable.  Semantic similarity clustering  helps to discern these behaviors by looking beyond the structural details of specific patterns and seeing trends in actual matching behavior.  We are also able to find out what features are being used in these behavioral trends so that we can make assertions about why certain features are important.

%\subsubsection{General Information About Clusters Found}
From 9,503 distinct patterns, the MCL clustering technique identified 514 clusters with 2 or more patterns, and 7,214 clusters of size 1.  Recall that only pairs of patterns with a similarity level of 0.75 were included in the matrix passed to MCL.  The average size of clusters larger than size one was 3.7.
%From 9503 distinct patterns, the MCL clustering technique identified 514 clusters with 2 or more patterns, and 7214 clusters of size 1.
%this section is repeated later, goes better there
%Recall that only pairs of patterns with a similarity level of 0.75 were included in the matrix passed to MCL.
%The average size of clusters larger than contains 3.7 patterns.
Each pattern belongs to exactly one cluster.
%\todo{It seems like we missed an opportunity here. There are two measures of the `influence' a cluster represents, one in its size (how many patterns) and another in how many projects. Did we weight the clusters at all by the number of projects in which the patterns are present?}


%\subsubsection{An Example Cluster}
Table~\ref{table:exampleCluster} provides an example of a behavioral cluster representing 13 patterns with at least one pattern from this cluster present in 100 different projects.  At first glance this cluster may seem to revolve around the `\verb!\s*!' parts of these patterns, but actually this cluster was formed because each of these patterns has a comma literal, and other details did not interfere with matching the Rex-generated strings with commas in them.
\input{../behavioral_clustering/exampleCluster}

%\subsubsection{Using the Smallest Pattern to Represent a Cluster}
The smallest pattern in Table~\ref{table:exampleCluster} is the single comma literal \verb!`,'! at index 1.  This smallest pattern gives the a good idea of what all the patterns within it have in common.  A shorter pattern will tend to have less extraneous behavior because it is specifying less behavior.  And yet in order for the smallest pattern to be clustered with other patterns, it had to match most of the strings created by Rex from another pattern within the cluster, and so we assume that {the smallest pattern is a good representation of the cluster}.

For the rest of this paper, a cluster will be represented by one of the shortest patterns it contains, followed by the number of projects a member of the cluster appears in, so the cluster in Table~\ref{table:exampleCluster} will be represented as \verb!`,'(100)!.
%The top 10 clusters are shown in Table~\ref{table:topNClusters}, ranked by the number of projects they appear in.
%\subsubsection{Catagorizing the Top 100 Clusters}
We  manually mapped the top 100 clusters into each of 6 behavioral categories, omitting 11 clusters that did not fit into any of these catagories, and 29 clusters composed of long strings (example: \verb!set_fabric_sense_len\)\(!) which were in the top 100 because 28 projects that were scanned were forked linux kernels.


Next, we define the six categories and provide examples from the relevant clusters.

\subsubsection{Single Literal Characters}
This category contains 19 clusters. Each of the clusters center around a single literal character. For example, three of the top clusters in this category include:
\verb!`\\'(110)!, \verb!`,'(100)!, and \verb!`:'(91)!. This is in contrast to the survey in Section~\ref{sec:survey} in which participants reported to very rarely or never use regexes to check for a single character (Table~\ref{tab:regexactivities}).
% \verb!`-'(74)!, \verb!`#'(69)!, \verb!` '(66)!, \verb!`/'(65)!, \verb!`\.'(61)!, \verb!`='(52)!, \verb!`//'(51)!, \verb!`\n'(41)!, \verb!`;'(38)!, \verb!`_'(36)!, \verb!`@'(36)!, \verb!`"'(33)!, \verb!`%'(29)!, \verb!`&'(28)!, \verb!`&'(28)!, \verb!`''(28)!

\subsubsection{Default Character Classes}
This category contains 12 clusters. Each of the clusters revolves around the use of a default character class. For example, three of the top clusters in this category are:
\verb!`\s'(277)!, \verb!`\W'(208)!, and \verb!`\d'(193)!. This corroborates our survey results to the question, \emph{Do you prefer to use custom character classes or default character classes more often?}, in which 56\% (10) of the participants indicated they use the default classes more than custom.
%\verb!`\w'(114)!, \verb!`\w+$'(71)!,
% \verb!`\D'(65)!, \verb!`\S'(53)!, \verb!`^\s'(40)!, \verb!`^\d+'(39)!, \verb!`^\s*'(39)!, \verb!`\d+$'(38)!, \verb!`\s*'(30)!

\subsubsection{User-Defined Character Classes}
This category contains 10 clusters. Each of the clusters center around user defined character classes. For example, three of the top clusters in this category are:
\verb!`[a-zA-Z]'(138)!, \verb!`[^!-~]'(122)!, and \verb!`[&<]'(50)!. This further supports our survey results in which 33\% (6) participants indicated they use the custom classes more than default. The remaining two participants use both equally.
% \verb!`[A-Z]'(47)!, \verb!`[ \t]'(37)!, \verb!`[-\s]'(35)!, \verb!`^[a-zA-Z]'(33)!, \verb!`[][\()<>@,:;"."]'(29)!, \verb!`[*?[]'(29)!, \verb!`[?/]+'(28)!


\subsubsection{ Matching Whole Strings}
This category contains 8 clusters. Each of the clusters begins with the STR anchor and ends with the END anchor, requiring the entire input string to match the pattern. For example, three of the top clusters in this category include:
\verb!`^\d+$'(78)!, \verb!`^\w+$'(74)!, and \verb!`^\s*$'(59)!.
%, \verb!`^[-\w]+$'(45)!, \verb!`^[a-zA-Z]\w*$'(43)!, \verb!`^[ ]*(#.*)?$'(41)!, \verb!`^[a-f0-9]{40}$'(34)!, \verb!`^\S+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+$'(29)!


\subsubsection{Parsing Angle Bracket Contents}
This category contains 5 clusters. Each of the clusters contains a pair of angle brackets that contain a repeating character class.  It appears that these clusters are being used to recognize or capture the contents of the angle brackets.  For example, three of the top clusters in this category include:
\verb!`<.+>'(63)!, \verb?`<!\s+([^<>]*)>'(35)?, and \verb!`(<[^<>]*)/>'(35)!. %, ,  \verb!`\(.*\)'(31)!
% too long for column width: \verb!`<([^>]*)>: \[0x([0-9a-f]+)-0x([0-9a-f]+)\]'(57)!,

\subsubsection{Capturing Variable Assignments}
This category contains 4 clusters. Each of the clusters contain an equals symbol and some pattern on either side of it, which appears to be a variable on the left of the equals sign and a value on the right.  This type of cluster is very likely used to capture the value of the variable assignment when parsing source code. For example, three of the top clusters in this category are:
\verb!`\nmd5_data = {\n([^}]+)}'(69)!, \verb!`.*rlen=([0-9]+)'(57)!, and \verb!`coding[:=]\s*([-\w.]+)'(48)!.
%, \verb!`((^|;)\s*charset=)([^;]*)'(34)!

%\subsubsection{Clusters Not Falling Into Any Category}
%\verb!`\d+\.\d+'(53)!, \verb!`\d+\.\d+\.\d+'(48)!, \verb!`".*"'(42)!,\verb!`*$'(42)!, \verb!`(^|.*:)\s*\w*("|\')'(41)!, \verb!`\(\*'(38)!, \verb!`/|-'(36)!, \verb!`.'(35)!, \verb!`\\|/'(31)!, \verb!`::'(30)!, \verb!`/\*'(29)!

\subsection{Summary}
\label{sec:clusterResults}
We used the behavior of individual patterns to form clusters, and identified six main categories that clusters belonged to.  Overall, we see that many clusters are defined by the presence of particular tokens, such as the comma for the cluster in Table~\ref{table:exampleCluster}.
These six categories define what users are doing with regexes at a high level: using default character classes, defining their own character classes, matching single characters, parsing variable assignments, parsing the contents of brackets, or matching whole lines. The higher frequency of default character class matching than custom character class matching corroborates our developer survey responses.
 One of the six common cluster categories, \emph{capturing variable assignments}, has a very specific purpose of parsing source code files. This shows a very specific and common use of regular expressions in practice.

%whereas each group in the second part is drawn from a subset of strings in the corpus known to contain at least one of the desired features.  We did this because the presence of a feature in a pattern can be easily lost





 %All 1375 projects containing at least 1 Rex-Compatible pattern


% We guide the results analysis for this research question based on the features \emph{not} supported by popular regex tools.
% Table~\ref{table:featureStats} shows the mapping from features to regex tools.





% \subsubsection{Feature Groups Overview}
% Instead of analyzing every feature independently, we chose small groups of conceptually related features.  For each of these groups, we selected all clusters that had at least one of the features in at least one pattern within the cluster to form a `feature group'-focused cluster set.

% Table~\ref{table:featureGroups} shows the total number of projects that contain at least one pattern from at least one cluster in the cluster set, and some selected clusters represented by the shortest string in the cluster.  These clusters were selected not because of being within the largest number of projects, but because they illustrate some interesting usage of a feature that will be explored in detail later.

% \input{../behavioral_clustering/featureGroups}


% (note that for the ANY group, all but two of the top 30 clusters used `.*', but that .* as a pattern alone only appeared in 23 projects)


% tell them how the cluster groups in the first part are all drawn from a subset of the corpus limited by what Rex can support, whereas the cluster groups in the second part are all drawn from the complete corpus, but are not guaranteed to have behavioral similarity like in the first part.


